About
=====

This is a simple URL redirector built using an API-only Rails backend, a
React frontend, an nginx reverse proxy, and Redis for caching. The
development environment is managed using docker-compose.

React
-----
The `frontend` folder contains the React code. It was built using `create-react-app` and 
is hosted using that tool's built-in webpack scripts, which makes development
super easy. 

Rails
-----
The `backend` folder contains a Rails server that hosts a JSON API and also resolves shortened links. 

Redis is used as the backend for the Rails cache. URLs are cached when looking them up for 
redirection. While the API to create shortened URLs performs more
database operations (for example, looking up a generated slug to ensure uniqueness), it seems likely
that the bulk of traffic would come to the url redirection controller.

The slug for shortened URLs is generated by creating a random 8-digit code using a 62-character alphabet. 
These slugs are looked up for uniqueness and regenerated if a duplicate is created 
(of which there is a very small chance of occurring).

nginx
-----
nginx is used as a reverse proxy to tie the app together under one host name.  Some 
url rewriting is used to detect where to redirect the request (i.e. the frontend server 
or backend server).  In a production deployment, I'd expect the frontend files to be hosted
directly by a static web server or a CDN. Caching could also be added to nginx to reduce
the load on the origin servers, but in this setup it just overcomplicates development.

nginx is also used as a load balancer, and in the `make server` target the backend
rails app is scaled in a 2-node container cluster.  Just for fun.

Postgres
--------
Postgres is used to host relational data. Unique indexes are added for both URLs and slugs 
in the single table used by the app. These indexes serve a single purpose - they back the 
application logic enforcing the uniqueness of these fields. They could also help to 
speed up `SELECT` queries if the volume of data in the table reaches a point 
where queries benefit from indexes.

Prerequisites
=============

Ubuntu 20.04 (other versions may work too)
------------------------------------------

-   Ensure you have `make` installed.

    sudo apt-get install make

-   Install docker and docker-compose
    https://docs.docker.com/engine/install/ubuntu/
    https://docs.docker.com/compose/install/

-   Add yourself to the newly-created `docker` group (the install above
    created that group, but you need to be in it now)

    sudo usermod -a -G docker \$USER

-   Now REBOOT YOUR MACHINE and confirm that you are in the `docker` group. 
    In a terminal, the `groups` command should list `docker` as one of your groups.

    groups

-   Ensure you have the docker service running before proceeding to setup. 

    systemctl status docker

MacOS
-----

-   Ensure you have `make` installed.

    xcode-select --install

-   Download and install Docker Desktop, which includes Docker Compose:
    https://docs.docker.com/desktop/mac/install/

-   Make sure you have Docker Desktop running before proceeding to setup.

Setup Environment
=================

Copy env-example to .env - the values should work without modification.

    cp env-example .env

Setup Docker
============

    make setup

Running tests
=============

Run the entire test suite:
--------------------------

    make test

Running just the rails tests:
-----------------------------

    docker-compose run backend bundle exec rspec

Running just the frontend tests:
--------------------------------

    docker-compose run frontend yarn test --watchAll=false

Running the app:
================

    make server

Now visit http://localhost:8082 (ignore any console output telling you
otherwise)
